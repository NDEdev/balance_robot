#pragma once

#ifdef __cplusplus

#include "mc_hardware_interfaces_base.h"

/*!
 * Класс предназначен для запуска таймера в
 * режим счета вверх до заданного значения.
 */
class TimCounterBase {
public:
	/*!
	 * Сбрасывает текущие настройки таймера и инициализирует его заново.
	 * После инициализации таймер остается отключенным.
	 *
	 * Замечание: управление тактовым сигналом аппаратного
	 * модуля осуществляется внутри метода автоматически.
	 *
	 * \param[in]	numberCfg		-	выбранная конфигурация таймера.
	 *
	 * \return		{	BASE_RESULT::OK					-	инициализация прошла успешно.
	 *					BASE_RESULT::INPUT_VALUE_ERROR	-	несуществующий номер конфигурации.
	 *					BASE_RESULT::ERROR_INIT			-	ошибка инициализации.
	 */
	virtual BASE_RESULT		reinit					( uint32_t numberCfg = 0 )						= 0;

	/*!
	 * Запускает таймера.
	 *
	 * \return		{	BASE_RESULT::OK					-	передача прошла успешно.
	 *					BASE_RESULT::ERROR_INIT			-	SPI не был инициализирован ранее.	}
	 */
	virtual	BASE_RESULT		on						( void )										= 0;

	/// Останавливает таймер.
	virtual	void			off						( void )										= 0;

	/// Возвращает текущее значение таймера.
	virtual	uint32_t		getCounter				( void )										= 0;
};

/*!
 * Класс предназначен для для генерации прямоугольных
 * импульсов на одном канале средствами аппаратного таймера.
 */
class TimCompOneChannelBase {
public:
	/*!
	 * Сбрасывает текущие настройки таймера и инициализирует его заново.
	 * После инициализации таймер остается отключенным.
	 *
	 * Замечание: управление тактовым сигналом аппаратного
	 * модуля осуществляется внутри метода автоматически.
	 *
	 * \param[in]	numberCfg		-	выбранная конфигурация таймера.
	 *
	 * \return		{	BASE_RESULT::OK					-	инициализация прошла успешно.
	 *					BASE_RESULT::INPUT_VALUE_ERROR	-	несуществующий номер конфигурации.
	 *					BASE_RESULT::ERROR_INIT			-	ошибка инициализации.
	 */
	virtual BASE_RESULT		reinit					( uint32_t numberCfg = 0 )						= 0;

	/*!
	 * Запускает таймера.
	 *
	 * \return		{	BASE_RESULT::OK					-	передача прошла успешно.
	 *					BASE_RESULT::ERROR_INIT			-	SPI не был инициализирован ранее.	}
	 */
	virtual	BASE_RESULT		on						( void )										= 0;

	/// Останавливает таймер.
	virtual	void			off						( void )										= 0;

};

/*!
 * Класс предназначен для генерации прерываний средствами аппаратного таймера.
 */
class TimInterruptBase {
public:
	/*!
	 * Сбрасывает текущие настройки таймера и инициализирует его заново.
	 * После инициализации таймер остается отключенным.
	 *
	 * Замечание: управление тактовым сигналом аппаратного
	 * модуля осуществляется внутри метода автоматически.
	 *
	 * \param[in]	numberCfg		-	выбранная конфигурация таймера.
	 *
	 * \return		{	BASE_RESULT::OK					-	инициализация прошла успешно.
	 *					BASE_RESULT::INPUT_VALUE_ERROR	-	несуществующий номер конфигурации.
	 *					BASE_RESULT::ERROR_INIT			-	ошибка инициализации.
	 */
	virtual	BASE_RESULT		reinit					( uint32_t numberCfg = 0 )						= 0;

	/*!
	 * Запускает таймера.
	 *
	 * \return		{	BASE_RESULT::OK					-	передача прошла успешно.
	 *					BASE_RESULT::ERROR_INIT			-	SPI не был инициализирован ранее.	}
	 */
	virtual	BASE_RESULT		on						( void )										= 0;

	/// Останавливает таймер.
	virtual	void			off						( void )										= 0;

	/*
	 * Сбрасывает флаг прерывания и совершает все необходимые
	 * действия чтобы можно было успешно выйти из прерывания.
	 */
	virtual void			clearInterruptFlag		( void )										= 0;

};

/*!
 * Класс предназначен для генерации PWM сигнала на одном канале аппаратного таймера.
 */
class TimPwmOneChannelBase {
public:
	/*!
	 * Сбрасывает текущие настройки таймера и инициализирует его заново.
	 * После инициализации таймер остается отключенным.
	 *
	 * Замечание: управление тактовым сигналом аппаратного
	 * модуля осуществляется внутри метода автоматически.
	 *
	 * \param[in]	numberCfg		-	выбранная конфигурация таймера.
	 *
	 * \return		{	BASE_RESULT::OK					-	инициализация прошла успешно.
	 *					BASE_RESULT::INPUT_VALUE_ERROR	-	несуществующий номер конфигурации.
	 *					BASE_RESULT::ERROR_INIT			-	ошибка инициализации.
	 */
	virtual BASE_RESULT		reinit					( uint32_t numberCfg = 0 )						= 0;

	/*!
	 * Запускает таймера.
	 *
	 * \return		{	BASE_RESULT::OK					-	передача прошла успешно.
	 *					BASE_RESULT::ERROR_INIT			-	SPI не был инициализирован ранее.	}
	 */
	virtual	BASE_RESULT		on						( void )										= 0;

	/// Останавливает таймер.
	virtual	void			off						( void )										= 0;

	/*!
	 * Устанавливает коэффициент заполнения ШИМ-сигнала.
	 * \param[in]	duty			-	кожффициент заполнения в диапазоне 0..1.
	 */
	virtual void			setDuty					( float duty )									= 0;

};

/*!
 * Класс предназначен для считывания значения аппаратного квадратурного энкодера.
 */
class TimEncoderBase{
public:
	/*!
	 * Сбрасывает текущие настройки таймера и инициализирует его заново.
	 * После инициализации таймер остается отключенным.
	 *
	 * Замечание: управление тактовым сигналом аппаратного
	 * модуля осуществляется внутри метода автоматически.
	 *
	 * \param[in]	numberCfg		-	выбранная конфигурация таймера.
	 *
	 * \return		{	BASE_RESULT::OK					-	инициализация прошла успешно.
	 *					BASE_RESULT::INPUT_VALUE_ERROR	-	несуществующий номер конфигурации.
	 *					BASE_RESULT::ERROR_INIT			-	ошибка инициализации.
	 */
	virtual BASE_RESULT		reinit					( uint32_t numberCfg = 0 )						= 0;

	/*!
	 * Запускает таймера.
	 *
	 * \return		{	BASE_RESULT::OK					-	передача прошла успешно.
	 *					BASE_RESULT::ERROR_INIT			-	SPI не был инициализирован ранее.	}
	 */
	virtual	BASE_RESULT		on						( void )										= 0;

	/// Останавливает таймер.
	virtual	void			off						( void )										= 0;

	/*!
	 * Возвращает знечения счётчика срабатываний квадратурного энкодера. Условие изменения счётчика
	 * и его максимальная величина задаются при конфигурации
	 */
	virtual uint32_t			getEncoderCounts					( void )									= 0;
};


class TimCaptureBase {
public:
	/*!
	 * Метод должен:
	 * 1. Отключить таймер.
	 * 2. Заполнить все необходимые регистры.
	 * Замечание: таймер при этом остается в отключенном состоянии.
	 */
	virtual bool	reinit					( uint32_t numberCfg = 0 )				= 0;

	/*!
	 * Метод возвращает факт того, что канал был заблокирован.
	 * После считывания флаг блокировки снимается если канал
	 * на текущий момент уже разблокирован или устанавливается
	 * повторно.
	 * Если по прежнему в заблокированном состоянии.
	 * \return	true	- канал существует и он не заблокирован.
	 * 			false	- канал заблокирован или не существует.
	 */
	virtual bool 	getStateChannel			( const uint32_t channel )				= 0;

	/*!
	 * Метод позволяет получить текущую частоту на канале захвата.
	 *
	 */
	virtual bool	getFrequency			( const uint32_t channel,
											  float& returnFrequency )				= 0;

	/*!
	 * Метод возвращает true, если по каналу gettingChannel было событие захвата частоты.
	 * После вызова метода флаг сбрасывается.
	 */
	virtual	bool	getFlagCaptureChannel	( const uint32_t channel )				= 0;


	/*!
	 * Метод должен включать таймер
	 * (не перетерая поля регистров).
	 */
	virtual bool on							( void )								= 0;

	/*!
	 * Метод должен отключать таймер
	 * (не перетерая поля регистров).
	 */
	virtual bool off						( void )								= 0;
};

#endif
